#ifndef TRM_ULTRACAM_CCD_H
#define TRM_ULTRACAM_CCD_H

#include <string>
#include <vector>
#include <algorithm>
#include <fstream>
#include <sstream>
#include "trm_subs.h"
#include "trm_windata.h"
#include "trm_ultracam.h"

namespace Ultracam {

  // these have to be pre-declared
  template <class T> class CCD_base;

  template <class T>
  std::ostream& operator<<(std::ostream& s, const CCD_base<T>& ccd);

  template <class T>
  std::istream& operator>>(std::istream& s, CCD_base<T>& ccd);

  /*! \brief CCD_base<Obj> provides a generic base class for the CCD class
   *
   * CCD_base<Obj> is a template class that defines the general members and
   * then acts as a base for both the generic version of CCD and the specialisation of CCD
   * for Windata objects in order to provide a uniform interface for CCD<T> and
   * CCD<Windata> objects. CCD_base is not to be used on its own and so its constructors are protected,
   * however it is virtually synonymous with 'CCD<Obj>'
   *
   * This avoids the repetition of many functions that would be needed for a template specialisation, while also avoiding
   * ending up with two separate classes. This makes it easier for later bundling inside MCCD
   */ 
 
  template <class Obj>
  class CCD_base {
  public:

    /*! \brief An iterator type for objects stored in a CCD
     *
     * CCD_base is a template class which bundles up objects of different
     * types into a "CCDs-worth". Some functions return an iterator that
     * depends upon the type of object bundled. optr provides a generic
     * type for such iterators.
     */
    typedef typename std::vector<Obj>::iterator optr;

    //! Return object closest to a given position, if one exists.
    bool closest(float x, float y, optr& itr);

    //! Return object closest to a given position if selected.
    bool selected(float x, float y, optr& itr);

    //! Add another object to a CCD
    void push_back(const Obj& obj);

    //! Delete an object from a CCD
    bool del_obj(float x, float y, Obj& deleted);

    //! Returns the number of objects.
    size_t size() const {return dat.size();} 

    /*! \brief Returns the i-th object
     *
     * An index function which enables direct access to the vector of objects.
     * This can be used to retrieve or modify objects, but be careful because it
     * makes it possible to add in an object inconsistent with those already stored
     * (e.g. an overlapping window). Use push_back(const Obj&) or 
     * modify(int, const Obj&) for safe addiion and changes to objects.
     * \param i the object number, starting from 0
     * \return the i-th object
     */
    Obj& operator[](int i){return dat[i];}

    /*! \brief Returns the i-th object
     *
     * An index function which enables direct access to the vector of objects.
     * This can be used to retrieve or modify objects, but be careful because it
     * makes it possible to add in an object inconsistent with those already stored
     * (e.g. an overlapping window). Use push_back(const Obj&) or 
     * modify(int, const Obj&) for safe addition and changes to objects.
     * \param i the object number, starting from 0
     * \return the i-th object
     */
    const Obj& operator[](int i) const {return dat[i];}

    //! Change an object
    void modify(int no, const Obj& obj);

    //! Checks that a CCD is valid.
    bool valid() const;

    //! Reads a CCD
    void read(std::ifstream& fin, bool swap_bytes);

    //! Skips a CCD
    void skip(std::ifstream& fin, bool swap_bytes);

    //! Reads a CCD, old format
    void read_old(std::ifstream& fin, bool swap_bytes);

    //! Skips a CCD, old format
    void skip_old(std::ifstream& fin, bool swap_bytes);

    //! Writes a CCD
    void write(std::ofstream& fout) const;

    //! ASCII output of a CCD
    friend std::ostream& operator<< <>(std::ostream& s, const CCD_base& ccd);

    //! ASCII input of a CCD
    friend std::istream& operator>> <>(std::istream& s, CCD_base& ccd);

    //! Resizing function
    void resize(int nobj){dat.resize(nobj);}

  protected:

    //! Default constructor
    CCD_base() {}

    //! Constructor of a CCD with nobj objects
    CCD_base(int nobj) : dat(nobj) {}

    //! Data
    std::vector<Obj> dat;

  };

  //! Function object defines "less than" for two objects.

  /** Defines what it means for one object to be "less" than
   * another in terms of how far each is from a given point. This is 
   * used by "selected". It requires each object to have a function
   * called how_far
   */
  template <class Obj>
  class Obj_less : public std::binary_function<Obj,Obj,bool> {
    float xc, yc;
  public:
    //! Constructor storing the fixed position
    Obj_less(float x, float y) : xc(x), yc(y) {}
    //! () operator to decide whether obj1 is closer than obj2
    bool operator()(const Obj& obj1, const Obj& obj2) const {
      return obj1.how_far(xc,yc) < obj2.how_far(xc,yc);
    }
  };

  // Now the member function definitions

  /**
   * This function returns an iterator of type optr which refers to 
   * the object closest to position (x,y). This requires each supported object
   * to have a function called 'how_far' to say how far they are from a given point. See the
   * \ref Aperture class for example.
   * \param x    X coordinate of position of interest.
   * \param y    Y coordinate of position of interest.
   * \param itr  iterator, if valid object found
   * \return true if an object found, else false
   */
  template <class Obj> 
  bool CCD_base<Obj>::closest(float x, float y, optr& itr) {
    if(size()){
      itr = dat.begin();
      float d, dis = itr->how_far(x,y);
      for(optr it=itr+1; it != dat.end(); it++){
	if((d = it->how_far(x,y)) < dis){
	  itr = it;
	  dis = d;
	}
      }
      return true;
    }else{
      return false;
    } 
  }

  /**
   * This function returns an iterator of type optr which refers to 
   * the object closest to position (x,y). It only does so however if the
   * object is "close enough" as defined by an equivalent function of the 
   * object. See the \ref Aperture class for example. Otherwise it returns
   * NULL.
   * \param x   X coordinate of position of interest.
   * \param y   Y coordinate of position of interest.
   * \param itr iterator pointing to the object closest to the input x,y position
   * \return An iterator is returned which is more-or-less a pointer to the object of interest. If
   * no object is found this will be NULL.
   */
  template <class Obj> 
  bool CCD_base<Obj>::selected(float x, float y, optr& itr) {
  
    if(closest(x,y,itr)) {

      // See if it is near enough

      if(itr->near_enough(x,y)){
	return true;
      }else{
	return false;
      }
    }else{
      return false;
    } 
  }

  /**
   * This function adds in another object to a CCD, checking for consistency with
   * any objects already stored. If there is a clash, it throws an Ultracam_Error.
   * \param obj the object to add in.
   */
  template <class Obj>
  void CCD_base<Obj>::push_back(const Obj& obj){
    for(size_t io=0; io<dat.size(); io++)
      if(clash(obj,dat[io])) 
	throw Ultracam::Ultracam_Error("New object overlaps an old one in void CCD_base<Obj>::push_back(const Obj& obj)");
    dat.push_back(obj);
  }
  
  // Delete the closest object to (x,y)
  /**
   * This function deletes the object closest to the position (x,y), if it
   * is close enough (see selected(float, float) for example)
   * If returns with true if selected and passes back a copy of the deleted object
   * which can be useful for plotting for example.
   * \param x X coordinate of point close to object to be deleted
   * \param y Y coordinate of point close to object to be deleted
   * \param deleted a copy of the the deleted object
   * \return true/false according to whether the object was successfully deleted.
   */
  template <class Obj>
  bool CCD_base<Obj>::del_obj(float x, float y, Obj& deleted){
    if(size()){
      optr sel;
      if(selected(x, y, sel)){
	deleted = *sel;
	dat.erase(sel);
	return true;
      }else{
	std::cerr << "Not near enough to any object to count" << std::endl;
	return false;
      }
    }else{
      std::cerr << "Nothing to delete" << std::endl;
      return false;
    } 
  }

  /**
   * This function allows you to change an object while checking for consistency with 
   * those already stored.
   * \param no object number to change, starting at 0
   * \param obj the new object
   * \exception Ultracam::Modify_Error thrown if new object inconsistent with old.
   */
  template <class Obj>
  void CCD_base<Obj>::modify(int no, const Obj& obj){
    if(no > size()-1)
      throw Ultracam::Modify_Error("no out of range in "
				   "void CCD<>::modify(int no, const Obj& obj");
    for(int io=0; io<size(); io++){
      if(io != no && clash(dat[io],obj))
	throw Ultracam::Modify_Error(std::string("New ") + Obj::name() +
				     std::string(" clashes with others in "
					    "void CCD<>::modify(int no, const Obj& obj"));
    
    }
    dat[no] = obj;
  }

  /**
   * Use of the index operator[](int i) can leave a CCD is an invalid
   * state. This is provided to test whether this has occurred.
   * \return \c true if CCD is OK, otherwise \c false.
   */

  template <class Obj>
  bool CCD_base<Obj>::valid() const {
    for(int io=1; io<size(); io++)
      for(int ib=0; ib<io; ib++)
	if(clash(dat[io],dat[ib])) return false;
    return true;
  }

  // Unformatted I/O

  /**
   * This function reads a CCD stored in binary format. Checks
   * are made for the validity of the resulting CCD.
   * \param fin input stream
   * \param swap_bytes whether or not to carry out byte swapping 
   * \exception An Ultracam::Read_Error is thrown if the CCD is not valid.
   */
  template <class Obj>
  void CCD_base<Obj>::read(std::ifstream& fin, bool swap_bytes){
    int nobj;
    fin.read((char*)&nobj,sizeof(int));
    if(swap_bytes) nobj = Subs::byte_swap(nobj);
    if(nobj != int(dat.size())) dat.resize(nobj);

    for(int io=0; io<nobj; io++){
      dat[io].read(fin, swap_bytes);
  
      // Guard against inconsistent objects
  
      for(int ib=0; ib<io; ib++)
	if(clash(dat[ib],dat[io]))
	  throw Ultracam::Read_Error(std::string("CCD_base<obj>::read(std::ifstream&): a ") + Obj::name() +
				     std::string(" clashed with one read earlier"));
    } 
  }

  /**
   * This function skips a CCD stored in binary format.
   * \param fin input stream
   * \param swap_bytes whether or not to carry out byte swapping 
   */
  template <class Obj>
  void CCD_base<Obj>::skip(std::ifstream& fin, bool swap_bytes){
    int nobj;
    fin.read((char*)&nobj,sizeof(int));
    if(swap_bytes) nobj = Subs::byte_swap(nobj);
    for(int io=0; io<nobj; io++)
      dat[io].skip(fin, swap_bytes); 
  }

  /**
   * This function reads a CCD stored in binary format. Checks
   * are made for the validity of the resulting CCD.
   * \param fin input stream
   * \param swap_bytes whether or not to carry out byte swapping 
   * \exception An Ultracam::Read_Error is thrown if the CCD is not valid.
   */
  template <class Obj>
  void CCD_base<Obj>::read_old(std::ifstream& fin, bool swap_bytes){
    size_t nobj;
    fin.read((char*)&nobj,sizeof(size_t));
    if(swap_bytes) nobj = Subs::byte_swap(nobj);
    if(nobj != dat.size()) dat.resize(nobj);
    for(size_t io=0; io<nobj; io++){
      dat[io].read_old(fin, swap_bytes);
  
      // Guard against inconsistent objects
      for(size_t ib=0; ib<io; ib++)
	if(clash(dat[ib],dat[io]))
	  throw Ultracam::Read_Error(std::string("CCD_base<obj>::read_old(std::ifstream&): a ") + Obj::name() +
				     std::string(" clashed with one read earlier"));
    } 
  }

  /**
   * This function skips a CCD stored in binary format.
   * \param fin input stream
   * \param swap_bytes whether or not to carry out byte swapping 
   */
  template <class Obj>
  void CCD_base<Obj>::skip_old(std::ifstream& fin, bool swap_bytes){
    size_t nobj;
    fin.read((char*)&nobj,sizeof(size_t));
    if(swap_bytes) nobj = Subs::byte_swap(nobj);
    for(size_t io=0; io<nobj; io++)
      dat[io].skip_old(fin,swap_bytes); 
  }

  /**
   * This function writes out a CCD stored in binary format.
   * \param fout output stream
   */
  template <class Obj>
  void CCD_base<Obj>::write(std::ofstream& fout) const {
    int nobj = dat.size();
    fout.write((char*)&nobj,sizeof(int));
    for(int io=0; io<nobj; io++)
      dat[io].write(fout);
  }

  // ASCII I/O

  /**
   * Outputs every object of a CCD using its own << operator
   * and appending a number to the object
   * \param s output stream
   * \param ccd CCD to be output 
   */
  template <class Obj>
  std::ostream& operator<<(std::ostream& s, const CCD_base<Obj>& ccd){
    s << "Number of " << Obj::plural_name() << " = " << ccd.size() << "\n" << std::endl;
    std::string name = Obj::name();
    name[0] = toupper(name[0]);
    for(size_t io=0; io<ccd.size(); io++){
      s << name << " " << io+1 << ": " << std::endl;
      s << ccd.dat[io] << std::endl;
    }
    return s;
  }

  /**
   * This function reads a CCD stored in binary format. Checks
   * are made for the validity of the resulting CCD.
   * \param s input stream
   * \param ccd CCD to be loaded
   * \exception An Ultracam::Read_Error is thrown if the CCD is not valid.
   */
  template <class Obj>
  std::istream& operator>>(std::istream& s, CCD_base<Obj>& ccd){
    char ch;

    size_t nobj;
    while(s.get(ch) && ch != '=');
    if(!s || !(s >> nobj)) 
      throw Ultracam::Read_Error("Invalid input into CCD_base::operator>> (1)");
    
    if(nobj != ccd.size()) ccd.resize(nobj);
  
    for(size_t io=0; io<nobj; io++){
      while(s.get(ch) && ch != ':');
      if(!s || !(s >> ccd[io]))
	throw Ultracam::Read_Error("Invalid input into CCD_base::operator>> (2)");
  
      // Guard against inconsistent objects

      for(size_t ib=0; ib<io; ib++)
	if(clash(ccd[ib],ccd[io]))
	  throw Ultracam::Read_Error(std::string("One ") + Obj::name() + std::string(" clashed with one read earlier"));
    }
    return s;
  }

  // Plot object in line form

  //! Plot a CCD in line form

  /**
   * This function plots all the objects in a CCD in line form and labels
   * each with a number corresponding to their storage position, starting from 1.
   * \param ccd the CCD to plot.
   * \relates CCD_base
   */
  template <class Obj>
  void pgline(const CCD_base<Obj>& ccd){
    for(size_t io=0; io<ccd.size(); io++){
      pgline(ccd[io]);
      pgptxt(ccd[io],Subs::str(io+1));
    }
  }

  // Now the first general CCD class, which is just
  // directly inherited from CCD_base with nothing extra.

  //! CCD<Obj> is the generic CCD class
  /**
   * CCD<Obj> is directly inherited from the CCD_base<Obj> class and
   * represents a CCDs worth of objects such as apertures, targets or
   * windows. Read the CCD_base<Obj> documentation for the supported functions.
   */ 

  template <class Obj>
  class CCD : public CCD_base<Obj> {
  public:
    //! Default constructor
    CCD() : CCD_base<Obj>() {}
    //! Constructor of nobj objects
    CCD(int nobj) : CCD_base<Obj>(nobj) {}
  };

  // Now the specialisation for Windata objects.

  //! CCD<Windata> is the specific CCD class for containing data.
  /**
   * CCD<Windata> is related to the generic CCD<Obj> class, but supports
   * a number of extra functions that only mean something for Windata
   * objects. This class is closest to representing what one thinks of as
   * a CCD image.
   */ 

  template <>
  class CCD<Windata> : public CCD_base<Windata> {
  public:

    //! Default constructor
    CCD() : CCD_base<Windata>() {}
 
    //! Constructor of nobj Windata objects
    CCD(int nobj) : CCD_base<Windata>(nobj) {}

    //! Copy constructor
    CCD(const CCD<Window>& win);

    //! Set all pixels of all Windata objects to a constant
    CCD& operator=(const Ultracam::internal_data& con);

    //! Set format of CCD to match a CCD of Windows
    CCD& operator=(const CCD<Window>& win);

    //! Add another CCD<Windata> in place
    void operator+=(const CCD& obj);

    //! Subtract another CCD<Windata> in place
    void operator-=(const CCD& obj);

    //! Mulitply by another CCD<Windata> in place
    void operator*=(const CCD& obj);

    //! Divide by another CCD<Windata> in place
    void operator/=(const CCD& obj);

    //! Add a constant to every pixel in place
    void operator+=(const Ultracam::internal_data& con);

    //! Subtract a constant from every pixel in place
    void operator-=(const Ultracam::internal_data& con);

    //! Multiply every pixel by a constant in place
    void operator*=(const Ultracam::internal_data& con);

    //! Divide every pixel by a constant in place
    void operator/=(const Ultracam::internal_data& con);

    //! Return unbinned X dimension of a CCD<Windata>
    int nxtot() const;

    //! Return unbinned Y dimension of a CCD<Windata>
    int nytot() const;

    //! Return minimum pixel value of a CCD<Windata>
    Ultracam::internal_data min() const;

    //! Return maximum pixel value of a CCD<Windata> over a region
    Ultracam::internal_data max(const CCD<Window>& window) const;

    //! Return minimum pixel value of a CCD<Windata> over a region
    Ultracam::internal_data min(const CCD<Window>& window) const;

    //! Return maximum pixel value of a CCD<Windata>
    Ultracam::internal_data max() const;

    //! Calculate the mean of a CCD<Windata>
    Ultracam::internal_data mean() const;

    //! Calculate a percentile over the whole frame
    void centile(float l, Ultracam::internal_data& c) const;

    //! Calculate two percentiles over the whole frame
    void centile(float l1, float l2, Ultracam::internal_data& c1, Ultracam::internal_data& c2) const;

    //! Calculate a percentile over a region of the frame
    void centile(float l, Ultracam::internal_data& c, const CCD<Window>& window) const;

    //! Calculate two percentiles over a region of the frame
    void centile(float l1, float l2, Ultracam::internal_data& c1, Ultracam::internal_data& c2, const CCD<Window>& window) const;

    //! Crop a CCD<Windata> to match the format of another
    void crop(const CCD<Windata>& ccd);

    //! Crop a CCD<Windata> to match the format of CCD<Window>
    void crop(const CCD<Window>& win);
 
    //! Window a CCD<Windata> by a CCD<Window>
    void window(const CCD<Window>& win);

    //! Writes out a CCD<Windata>
    void write(std::ofstream& fout, Windata::Out_type otype=Windata::NORMAL) const;

    //! Structure containing some basic statistics
    /**
     * This structure is used by statistics(const CCD<Window>&, float, bool) as a return
     * value when computing statistics over an arbitrary region of a CCD.
     */
    struct Stats {

      //! The number of valid points in the region defined.
      size_t npoints;

      //! The maximum value
      float  max;

      //! The minimum value
      float  min;

      //! The mean of all the points
      float  raw_mean;

      //! The RMS of all the points
      float  raw_rms;

      //! The mean after outlier rejection
      float  clipped_mean;

      //! The RMS after outlier rejection
      float  clipped_rms;

      //! The number of outliers rejected
      size_t nrejected;

      //! The median value
      float  median;
    };

    //! Statistics function
    Stats statistics(const CCD<Window>& statwin, float sigma, bool compute_median=true) const;

    //! Simple class for passing back raw data
    struct Buff{
      //! Number of pixels stored
      size_t ndat;
      //! Pointer to data buffer
      Ultracam::internal_data *dat;
    };

    //! Function to return raw data over a special region.
    Buff buffer(const CCD<Window>& ccdwin) const;

    //! Returns reference to Windata eclosing a given point
    Windata& enclose(float x, float y);

    //! Returns reference and number of Windata eclosing a given point
    Windata& enclose(float x, float y, int& which);

    //! Returns reference to Windata eclosing a given point
    const Windata& enclose(float x, float y) const;

    //! Returns reference and number of Windata eclosing a given point
    const Windata& enclose(float x, float y, int& which) const;

  };

  //! Compute the minimum value
  Ultracam::internal_data min(const CCD<Windata>& obj);

  //! Compute the maximum value
  Ultracam::internal_data max(const CCD<Windata>& obj);

  //! Compute the minimum value over a region
  Ultracam::internal_data min(const CCD<Windata>& obj, const CCD<Window>& window);

  //! Compute the maximum value over a region
  Ultracam::internal_data max(const CCD<Windata>& obj, const CCD<Window>& window);

  //! Test two CCD<Windata> objects for equality
  bool operator==(const CCD<Windata>& ccd1, const CCD<Windata>& ccd2);

  //! Test two CCD<Windata> objects for inequality
  bool operator!=(const CCD<Windata>& ccd1, const CCD<Windata>& ccd2);


  //! Draw a CCD<Windata> as a greyscale image
  void pggray(const Ultracam::CCD<Ultracam::Windata>& ccd, float lo, float hi);
  
  //! Label a CCD<Windata>
  void pgptxt(const Ultracam::CCD<Ultracam::Windata>& ccd);

};

#endif









