#ifndef TRM_WINDATA_H
#define TRM_WINDATA_H

#include <cstdlib>
#include <iostream>
#include <iomanip>
#include <fstream>
#include <string>
#include "subs.h"
#include "Window.h"
#include "ultracam.h"

using Subs::operator+;

//! Windata objects represent the data and format of individual readout windows

/** Windata objects take the window format defined by Window objects and add data. Bundled up
 * into CCDs and ultimately, multi-CCDs they form the basis of the storage of Frame objects.
 */ 

class Windata : public Window {

public:

  //! Enumeration defining the possible disk output data types
  /** \param NORMAL data type corresponding to the internally stored type, Ultracam::internal_data
   * \param RAW data type corresponding to the raw data from ULTRACAM
   */
  enum Out_type {NORMAL, RAW};

  //! Name to use when referring to Windata objects
  static string name(){return "windata";}

  //! Default constructor
  Windata();

  //! General constructor
  Windata(Ultracam::pix_num llx, Ultracam::pix_num lly, Ultracam::pix_num nx, Ultracam::pix_num ny, 
	  Ultracam::bin_fact xbin, Ultracam::bin_fact ybin, Ultracam::pix_num nxtot, 
	  Ultracam::pix_num nytot);

  //! Copy constructor from a Window
  Windata(const Window& window); 

  //! Copy constructor
  Windata(const Windata& windata);

  //! Destructor
  ~Windata() {dealloc();}
  
  //! Assignment to another Windata
  Windata& operator=(const Windata& windata); 

  //! Assignment to a Window
  Windata& operator=(const Window& window); 

  //! Assignment to a constant
  Windata& operator=(const Ultracam::internal_data& con); 

  //! Resizing function
  void resize(Ultracam::pix_num nx, Ultracam::pix_num ny);

#ifndef DEBUG

  //! Index operator for fast data access (if not DEBUG)
  Ultracam::internal_data* operator[](Ultracam::pix_num iy){return dat[iy];}

  //! Index operator for fast data access (if not DEBUG)
  const Ultracam::internal_data* operator[](Ultracam::pix_num iy) const {return dat[iy];}

#else

  // range checked version

  //! Range-checked index (if DEBUG)
  Ultracam::CheckX& operator[](Ultracam::pix_num iy){
    if(iy < 0 || iy >= ny()) 
      throw Ultracam::Ultracam_Error(
				     string("Windata::operator[](Ultracam::pix_num) error: iy = ") + iy +
				     string(" but should lie from 0 to ") + (ny()-1));
    return dat[iy];
  }

  //! Range-checked index (if DEBUG)
  const Ultracam::CheckX& operator[](Ultracam::pix_num iy) const{
    if(iy < 0 || iy >= ny()) 
      throw Ultracam::Ultracam_Error(
				     string("Windata::operator[](Ultracam::pix_num) error: iy = ") + iy +
				     string(" but should lie from 0 to ") + (ny()-1));
    
    return dat[iy];
  }

#endif

  // Conversion for sending to functions that work on 2D arrays, e.g. findpos
#ifndef DEBUG
  //! Conversion operator returning 2D array pointer for fast access (if not DEBUG)
  operator Ultracam::internal_data** () const {return dat;}

  //! Conversion operator returning 2D array pointer for fast access (if not DEBUG)
  operator Ultracam::internal_data** () {return dat;}
#else
  //! Conversion operator returning 2D array pointer for checked index access (if DEBUG)
  operator Ultracam::CheckX* () {return dat;}
#endif

  //! Binary output
  void write(ofstream& fout, Out_type otype=NORMAL) const;

  //! Binary input
  void read(ifstream& fin);

  //! Skip binary data
  void skip(ifstream& fin);


  //! ASCII output
  friend ostream& operator<<(ostream& s, const Windata& obj);

  // A few basic statistics

  //! Returns maximum value
  Ultracam::internal_data max()  const;

  //! Returns minimum value
  Ultracam::internal_data min()  const;

  //! Returns mean value
  Ultracam::internal_data mean() const;

  //! Returns rms value
  Ultracam::internal_data rms()  const;

  //! Returns sum value
  Ultracam::internal_data sum()  const;

  //! Calculates a percentile
  void centile(float l, Ultracam::internal_data& c) const;

  //! Calculates two percentiles
  void centile(float l1, float l2, Ultracam::internal_data& c1, Ultracam::internal_data& c2) const;

  //! Window a Windata to joint overlaap with a Window
  Windata window(const Window& win) const;

  //! Addition of another Windata in place
  void operator+=(const Windata& obj);

  //! Subtraction of another Windata in place
  void operator-=(const Windata& obj);

  //! Multiplication by another Windata in place
  void operator*=(const Windata& obj);

  //! Division by another Windata in place
  void operator/=(const Windata& obj);

  //! Addition of a constant in place
  void operator+=(const Ultracam::internal_data& con);

  //! Subtraction of a constant in place
  void operator-=(const Ultracam::internal_data& con);

  //! Multiplication by a constant in place
  void operator*=(const Ultracam::internal_data& con);

  //! Division by a constant in place
  void operator/=(const Ultracam::internal_data& con); 

  //! Defines the level of ASCII output
  static void set_print_level(int level);

  //! Returns the level of ASCII output
  static int print_level(){return plevel;}

  //! Copies data to a 1D array
  Ultracam::internal_data* buffer() const {
    Ultracam::internal_data *t, *p;
    t = p = new Ultracam::internal_data [ntot()];
    if(p){
      for(Ultracam::pix_num iy=0; iy<ny(); iy++)
	for(Ultracam::pix_num ix=0; ix<nx(); ix++, t++)
	  *t = dat[iy][ix];
    }
    return p;
  }

  //! Copy data into a 1D array provided by the user
  void copy(Ultracam::internal_data *p) const {
    if(p){
      Ultracam::internal_data *t = p;
      for(Ultracam::pix_num iy=0; iy<ny(); iy++)
	for(Ultracam::pix_num ix=0; ix<nx(); ix++, t++)
	  *t = dat[iy][ix];
    }
  }

private:

#ifndef DEBUG
  Ultracam::internal_data **dat;     // standard 2D C array

#else
  Ultracam::CheckX *dat;     // range checked case

#endif

  void alloc();            // memory allocator
  void dealloc();          // memory deallocator
  static int plevel;       // defines nature of ASCII output

  // Prevent access to set_nx and set_ny

  void set_nx(Ultracam::pix_num);
  void set_ny(Ultracam::pix_num);

};

// Non-member functions

//! Returns maximum of a Windata
Ultracam::internal_data max(const Windata& obj);

//! Returns minimum of a Windata
Ultracam::internal_data min(const Windata& obj);

//! Plot as a greyscale image
void pggray(const Windata& obj, float lo, float hi);

#endif

















